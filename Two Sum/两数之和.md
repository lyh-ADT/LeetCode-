## [LeetCode两数之和](https://leetcode-cn.com/problems/two-sum/description/)
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的**两个**整数。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

这道题最直接想到的是两层循环遍历数组, 找出`target-nums[i]`，时间复杂度是O(n<sup>2</sup>)
后来想到用哈希表，但是对C++的Map不熟悉，所以就直接提交了两层循环，居然过了，之前还以为是ACM那样有严格时间限制的
***
使用哈希表的方式是先将`nums`里面的元素作为key，对应的下标作为value,存起来，遍历一次直接查询，时间复杂度就是O(n)了
