## [LeetCode缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:
```
输入: [1,2,0]
输出: 3
```
示例 2:
```
输入: [3,4,-1,1]
输出: 2
```
示例 3:
```
输入: [7,8,9,11,12]
输出: 1
```
说明:
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。
***
由于对复杂度有要求，所以不能先排序                   
找的是正整数，先把所有非正整数移除
```
for(auto i=nums.begin(); i != nums.end();){
    if(*i <= 0){
        i = nums.erase(i);
    }else
        ++i;
}
```
> 注意这个erase()函数，它会返回删除元素之后的迭代器
如果erase最后一个元素直接++的话会到不了nums.end()，会堆溢出

由于剩下的都是正整数了，所以我们可以用负数作为标记，把小于`num.size()`的正整数都映射到其在`nums`的对应位置上（把对应位置上的值变成负数，表示数字`下标 + 1`已经出现过了）
```
if( t-1 < nums.size() && nums[t-1] > 0){
    nums[t-1] = -nums[t-1];
}
```
之后再遍历一次找到第一个非负的数
- 如果没有小于`nums.size()`的值，直接返回`1`
- 如果全都映射到了，返回`nums.size()+1`
- 否则返回`第一个正数的下标值+1`