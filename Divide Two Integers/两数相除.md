## [LeetCode两数相除](https://leetcode-cn.com/problems/divide-two-integers/)

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数`dividend`除以除数`divisor`得到的商。

示例 1:
```
输入: dividend = 10, divisor = 3
输出: 3
```
示例 2:
```
输入: dividend = 7, divisor = -3
输出: -2
```
说明:
- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31</sup> − 1]。本题中，如果除法结果溢出，则返回 2<sup>31</sup> − 1。
***
`TLESubmit.cpp`是超时(Time Limit Exceeded)的提交, 直接不断的用`被除数 - 除数`直到`被除数 < 除数`
           
看了评论里面的一个大神的          
通过左移`<<`(这不是`乘2`吗?!)使`除数`不断逼近`被除数`, 然后让余数继续**除以**`除数`, 直到`被除数 < 除数`
```
tr = 除数;
result = 1;
while (被除数 > tr) {
    tr <<= 1;
    result <<= 1;
}
if (被除数 < tr) {
    result = (result >> 1) + divide(被除数 - (tr >> 1), abs(除数));
    这里的(result >> 1)和(tr >> 1)是让result和tr回到 被除数 > tr 的时候
    被除数 - (tr >> 1)将剩下的(余数)作为被除数
}
```
```
if (被除数 < 除数) {
    return 0;
}
```
因为`被除数`和`除数`正负号不同, `被除数 > tr`的情况就不一样, 所以取绝对值处理           

结果`result`与`被除数`和`除数`正负号有关, 所以先进行判断`result`的正负号
```
bool negative = false;
if ((dividend & divisor & INT32_MIN) == 0 && (dividend < 0 || divisor < 0)) {
    negative = true;
}
```
`有符号整型`在内存是以`补码`的形式存放, 32位最高位是`符号位`(0正1负)
```
十进制          内存中的二进制
 2147483647 =  01111111 11111111 11111111 11111111  (2^31-1)
+         1 =  10000000 00000000 00000000 00000000
相当于-0, 然而0不需要判断正负号, 所以让-2147483647 - 1 = -2147483648
-2147483647 =  11111111 11111111 11111111 11111111  (-2^31-1)
-         1 =  10000000 00000000 00000000 00000000  (-2^31)
```
所以`INT32_MIN`除`符号位`外都是`0`, `(dividend & divisor & INT32_MIN)`(`按位与运算`)只要有一个`符号位`为`0`(即`dividend`和`divisor`有任意一个为`正数`), 该表达式的值为`0`, 再判断`(dividend < 0 || divisor < 0)`就可以断定`除数`和`被除数`是否异号