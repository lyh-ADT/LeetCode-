## [LeetCode通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

给定一个字符串`(s)`和一个字符模式`(p)`，实现一个支持`'?'`和`'*'`的通配符匹配。

`'?'`可以匹配任何单个字符。
`'*'`可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
示例 1:
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
示例 2:
```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```
示例 3:
```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```
示例 4:
```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```
示例 5:
```
输入:
s = "acdcb"
p = "a*c?b"
输入: false
```
***
用动态规划来做, `p`为一维坐标, `s`为二维坐标, 下标从1开始                     
两边字符串都为空时, 可以匹配, 将`dp[0][0]`置为`true`, `dp[0][i]`置为`false`, 分类后按行遍历
- `*`
前缀`*`可以匹配所有, `p[i]`为`*`时, 将整行置为`true`, 如果上一个字符不匹配(为`false`), 向下传递, 把`dp[i][j]`置为`false`
```
dp[i][j] = (dp[i][j-1] || dp[i-1][j] || dp[i-1][j-1]);
```
- `'?'`
不需要判断, 直接传递上一个字母的匹配情况, 将`dp[0][i]`置为`false`, 来匹配`s`已经结束, `'?'`没有字母匹配的情况
```
dp[i][j] = dp[i-1][j-1];
```
- `default`
`s[j-1] == p[i-1]`且上个字母匹配
```
dp[i][j] = (s[j-1] == p[i-1] && dp[i-1][j-1]);
```
***
第一名的代码
```
fun(s, p):
    sptr = 指向s的第一个元素
    ptr  = 指向p的第一个元素
    pstar = 指向p字符串中*的位置
    sstar = 指向s字符串中开始匹配*的位置

    while sptr指向的不是字符串的结束('\0'):
        if sptr == ptr 或者 ptr 指向 '?':
            sptr++
            ptr++
        else if ptr指向* :
            pstar = ptr++
            sstart = sptr
        else if pstar不为空(存在*): 
            // 当其余情况匹配失败后进入
            ptr = pstar + 1 
            /* 
             * 不需要修改pstar的值, 每次只匹配一个*, 
             * 只有当这个*匹配成功之后, 才进行接下来的*的匹配
             */
            sptr = ++sstar 
            // 将sptr指向上一次开始匹配*的后一个字母, 不断向后滑动
        else:
            return false

    while ptr指向*:
        ptr++
    if ptr指向p的结束('\0'):
        return true
    else:
        return false
```

