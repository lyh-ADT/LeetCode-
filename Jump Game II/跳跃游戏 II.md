## [LeetCode跳跃游戏II](https://leetcode-cn.com/problems/jump-game-ii/)

给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
示例:
```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```
说明:
假设你总是可以到达数组的最后一个位置。
***
第一次用从后往前的找最远距离的O(n<sup>2</sup>)贪心超时了[TLESubmit.cpp](./TLESubmit.cpp)            

然后看了看评论，里面有个大神，用了个O(n)的方法，赶紧学下来


- 他用一个变量保存目前能达到的最远的下标，在我的代码里面是`cur_max_reach`
- 一个变量保存目前所在的下标，我的代码里面是`cur_position`

从`0`到`size-1`遍历整个数组
```
cur_max_reach = max(i + nums[i], cur_max_reach);
```
其中，`i + nums[i]`表示的是，当前这个下标，加上自己能走的距离，可以去到的位置，因为题目说明必定有解，所以每一个下标的位置都是肯定能到达的，上面这样比较之后，`cur_max_reach`表示的就是从`0 ~ i`的最大能到达的距离
```
if (cur_max_reach >= n - 1)
     return steps + 1;
```
如果出现能走到最后的情况，直接返回
```
if (i == cur_position) {
     ++steps;
     cur_position = cur_max_reach;
}
```
如果`i`到达了之前最远的距离，那么算上这一步，并且更新当前的位置