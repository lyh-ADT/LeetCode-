## [LeetCode整数反转](https://leetcode-cn.com/problems/reverse-integer/)

给出一个 `32` 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:
```
输入: 123
输出: 321
```
 示例 2:
```
输入: -123
输出: -321
```
示例 3:
```
输入: 120
输出: 21
```
#### 注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2<sup>31</sup>,  2<sup>31−1</sup>]。请根据这个假设，如果反转后整数溢出那么就返回 0。

***

主要的思路就是用`%10`取出个位数的数, 乘上`权重`加到`result`中,用`/10`去掉个位上的数

```
for (int t = 输入; t > 0; t /= 10) {
    result += t % 10 * 权重;
}
```
权重其实就是10<sup>k</sup>,k=0,1,2,3...对应着个位,十位,百位,千位...             
在计算位数的时候就可以顺便把最高位的权重算出来,因为k从0开始所以权重的初始值是0.1
```
int length = 0;
double tbit = 0.1;
for (int t = 输入; t > 0; t /= 10) {
    tbit *= 10;
    length++;
}
```
因为有可能超出`最大值`所以要判断, 判断的方式就是`最大值`顺序的每一位和`result`的每一位进行比较    
- 如果有一位`result`的比`最大值`的小,那么`result`肯定会比`最大值`小,也就不需要再判断
- 如果有一位`result`的比`最大值`的大,那么`result`肯定大于`最大值`直接`return 0`
- 如果一位`result`和`最大值`相等,那么先不作结论
```
for (int t = abs(输入); t > 0; t /= 10) {
    if (length == 10 && unsurerange) {
        if (t % 10 > tMax / bit) {
            return 0;
        } else {
            if (t % 10 < tMax / bit) {
                unsurerange = false;
            }
        }
        tMax = tMax % bit;
    }
}
```
由于上述的大小判断是在非负数的情况下讨论的,负数情况相反,所以代码中通过取绝对值(abs),在返回的时候再加正负号来简化代码